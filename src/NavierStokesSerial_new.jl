function run_test_serial(mesh_file::String,force_file::String,Œît,tf,Œîtout)

  io = open("output.log", "w")
  forces_path=ENV["PerforatedCylinder_FORCES"]
  full_force_path = joinpath(forces_path,force_file)
  io_force = open(full_force_path, "w")
  function to_logfile(x...)
    write(io,join(x, " ")...)
    write(io,"\n")
    flush(io)
  end
  function to_forcefile(x...)
    write(io_force,join(x, " ")...)
    write(io_force,"\n")
    flush(io_force)
  end

  # Geometry
  to_logfile("Geometry")
  DIRICHLET_tags = ["inlet", "walls"]#, "monopile"]
  DIRICHLET_masks = [(true,true),(false,true)]#,(true,true)]
  meshes_path=ENV["PerforatedCylinder_MESHES"]
  full_mesh_path = joinpath(meshes_path,mesh_file)
  to_logfile("Mesh file: ",full_mesh_path)
  testname = replace(mesh_file,".msh" =>"")
  model =  GmshDiscreteModel(full_mesh_path)
  Œ© = Triangulation(model)
  Œ©_f = Triangulation(model, tags = "fluid")
  Œì_S = Boundary(model, tags = "monopile")
  Œì_out = Boundary(model, tags = "outlet")
  writevtk(model,testname)

  to_logfile("Measures")
  order = 2
  degree = 2 * order
  dŒ©_f = Measure(Œ©_f, degree)
  dŒì‚Çõ = Measure(Œì_S, degree)
  dŒìout = Measure(Œì_out, degree)
  n_ŒìS = get_normal_vector(Œì_S)
  n_Œìout = get_normal_vector(Œì_out)

  # Physics parameters
  to_logfile("Parameters")
  rho = 1.0e3#1.025e3 # kg/m^3
  Vinf = 1 # m/s
  Œº_f = 1.0e0# rho * Vinf * D / Re #0.01 # Fluid viscosity
  ŒΩ_f = Œº_f / rho # kinematic viscosity

  # Boundary conditions and external loads
  dims = num_cell_dims(model)
  u0(x,t,::Val{2}) = VectorValue(0.0, 0.0)
  u1(x,t,::Val{2}) = VectorValue( Vinf, 0.0 )
  u0(x,t,::Val{3}) = VectorValue(0.0, 0.0, 0.0)
  u1(x,t,::Val{3}) = VectorValue( Vinf, 0.0, 0.0 )
  u0(x,t::Real) = u0(x,t,Val(dims))
  u1(x,t::Real) = u1(x,t,Val(dims))
  u0(t::Real) = x -> u0(x,t,Val(dims))
  u1(t::Real) = x -> u1(x,t,Val(dims))
  U0_dirichlet = [u1, u1]#, u0]
  g(x) = 0.0

  # ODE solver
  t‚ÇÄ = 0.0 # start [s]
  œÅ‚àû = 0.5

  to_logfile("FE spaces")
  # ReferenceFE
  reffe·µ§ = ReferenceFE(lagrangian, VectorValue{dims,Float64}, order)#,space=:P)
  reffe‚Çö = ReferenceFE(lagrangian, Float64, order - 1)#,space=:P)

  # Define test FESpaces
  V = TestFESpace(Œ©, reffe·µ§,  dirichlet_tags = DIRICHLET_tags, dirichlet_masks=DIRICHLET_masks, conformity = :H1)
  Q = TestFESpace(Œ©, reffe‚Çö,   conformity= :C0)
  Œö = TestFESpace(Œ©, reffe·µ§,  dirichlet_tags = DIRICHLET_tags, dirichlet_masks=DIRICHLET_masks, conformity = :H1)
  Y = MultiFieldFESpace([V, Q])
  # Y‚ÇÄ = MultiFieldFESpace([V, Q])

  # Define trial FESpaces from Dirichlet values
  U = TransientTrialFESpace(V, U0_dirichlet)
  P = TrialFESpace(Q)
  Œó = TrialFESpace(Œö,[VectorValue(0.0,0.0),VectorValue(0.0,0.0)])#,VectorValue(0.0,0.0)])
  X = TransientMultiFieldFESpace([U, P])
  X‚ÇÄ = MultiFieldFESpace([U(0.0), P])

  # Stokes for pre-initalize NS
  a((u, p), (v, q)) = ‚à´( 2ŒΩ_f*(Œµ(v)‚äôŒµ(u)) )dŒ©_f - ‚à´( (‚àá‚ãÖv)*p + q*(‚àá‚ãÖu))dŒ©_f
  l((v, q)) = 0
  stokes_op = AffineFEOperator(a,l,X‚ÇÄ,Y)

  # Linear Solver
  to_logfile("Stokes solve")
  ls‚ÇÄ = LUSolver()
  u_ST, p_ST = solve(ls‚ÇÄ,stokes_op)

  # initial condition NS
  to_logfile("Navier-Stokes operator")
  xh‚ÇÄ = interpolate_everywhere([u_ST, p_ST],X(0.0))

  # Stabilization Parameters
  c‚ÇÅ = 12.0
  c‚ÇÇ = 2.0
  cc = 4.0
  h, h2 = get_mesh_sizes(Œ©)
  œÑ‚Çò, œÑc, dœÑ‚Çò, dœÑc = get_stabilization_parameters_(ŒΩ_f, c‚ÇÅ, c‚ÇÇ, cc)

  # Orthogonal projection
  aŒ∑(u) = (Œ∑,Œ∫) -> ‚à´( œÑ‚Çò(u,h,h2)*(Œ∑‚ãÖŒ∫) )dŒ©_f
  bŒ∑(u) = (Œ∫) -> ‚à´( œÑ‚Çò(u,h,h2)*((u‚ãÖ‚àá(u))‚ãÖŒ∫) )dŒ©_f
  op_proj(u) = AffineFEOperator(aŒ∑(u),bŒ∑(u),Œó,Œö)
  ls_proj = LUSolver()
  Œ∑‚Çï(u) = solve(ls_proj,op_proj(u))
  fv_u = zero_free_values(U(0.0))
  u‚Çô‚Çï(u,t) = interpolate!(u,fv_u,U(t-Œît))

  buffer = Ref{Any}((Œ∑=nothing,t=nothing))
  function Œ∑(u,t)
    if buffer[].t == t
      return buffer[].Œ∑
    else
      println("Computing Œ∑")
      buffer[] = (Œ∑=Œ∑‚Çï(u),t=t)
      return buffer[].Œ∑
    end
  end
  buffer2 = Ref{Any}((u=nothing,t=nothing))
  function u‚Çô(u,t)
    if buffer2[].t == t
      return buffer2[].u
    else
      println("Computing u‚Çô")
      buffer2[] = (u=u‚Çô‚Çï(u,t),t=t)
      return buffer2[].u
    end
  end

  # Wall law
  œá = 0.4
  B = 5.5
  Œ≥ = 100.0
  C·µ¶ = 32.0
  f‚Çú(u) = u + exp(-œá*B)*(exp(œá*u) - 1.0 - œá*u - 0.5*(œá^2*u^2) -(1/6)*(œá^3*u^3) )
  df‚Çú(u) = 1 + œá*exp(-œá*B)*(exp(œá*u) - 1.0 - œá*u - 0.5*(œá^2*u^2) )
  œÑ_(h) = C·µ¶*ŒΩ_f/h
  y‚Å∫_(h,abs·µ§,œÑ) = h/(Œ≥*ŒΩ_f)*‚àö(abs·µ§*œÑ)
  I = TensorValue(1.0,0.0,0.0,1.0)
  function œÑ·µ¶(u,u‚ÇÄ,h,n)
    u‚Çú = (I-n‚äón)‚ãÖ(u-u‚ÇÄ)
    abs·µ§ = norm(u‚Çú)
    œÑ = œÑ_(h)
    u‚Å∫ = ‚àö(abs·µ§/œÑ)
    y‚Å∫ = u‚Å∫
    r = y‚Å∫ - f‚Çú(u‚Å∫)
    while abs(r) > 1.0e-6
      dr = h/(2ŒΩ_f*Œ≥)*‚àö(abs·µ§/œÑ) + df‚Çú(u‚Å∫)*0.5*(‚àö(abs·µ§/(œÑ^3)))
      dœÑ = -r/dr
      œÑ += dœÑ
      u‚Å∫ = ‚àö(abs·µ§/œÑ)
      y‚Å∫ = y‚Å∫_(h,abs·µ§,œÑ)
      r = y‚Å∫ - f‚Çú(u‚Å∫)
    end
    œÑ‚Çú = œÑ*(I-n‚äón)
    œÑ‚Çô = Œ≥*œÑ_(h)*(n‚äón)
    return œÑ‚Çú+œÑ‚Çô
  end
  buffer3 = Ref{Any}((œÑ·µ¶=nothing,t=nothing))
  function œÑ·µ¶(u,u‚ÇÄ,h,n,t)
    if buffer3[].t == t
      return buffer3[].œÑ·µ¶
    else
      println("Computing œÑ·µ¶")
      buffer3[] = (œÑ·µ¶=œÑ·µ¶‚àò(u,u‚ÇÄ,h,n),t=t)
      return buffer3[].œÑ·µ¶
    end
  end

  # TMP weak form
  # stab_expl_(u,p,v,q,t) = ‚à´( œÑ‚Çò(u,h,h2) * ((‚àá(u)'‚ãÖu + ‚àá(p) - Œ∑(u‚Çô(u,t),t))‚ãÖ(‚àá(v)'‚ãÖu)+‚àá(q)) )dŒ©_f
  ùíû·µ§(a,‚àáu) = a‚ãÖ‚àáu
  ‚Ñí·µ§(a,‚àáu,‚àáp) = ùíû·µ§(a,‚àáu) + ‚àáp
  ùí´·µ§(a,‚àáu,‚àáp,Œ∑) = ‚Ñí·µ§(a,‚àáu,‚àáp) - Œ∑
  skew_conv(a,u,v,‚àáu,‚àáv) =  0.5*(ùíû·µ§(a,‚àáu)‚ãÖv - ùíû·µ§(a,‚àáv)‚ãÖu)
  sym_lapl(Œµu,Œµv) = 2ŒΩ_f*(Œµu‚äôŒµv)
  div_term(divu,q) = divu*q
  skew_conv_Œì(a,u,v,n) = (u‚ãÖv)*(0.5*(a‚ãÖn)-neg(a‚ãÖn))
  penalty(œÑ,u‚ÇÄ,u,v) = (œÑ‚ãÖ(u-u‚ÇÄ))‚ãÖv
  dpenalty(œÑ,du,v) = (œÑ‚ãÖdu)‚ãÖv
  complementary_uv(u‚ÇÄ,u,Œµv,n) = 2ŒΩ_f * ((n‚ãÖŒµv)‚ãÖ(u-u‚ÇÄ))
  complementary_uq(u‚ÇÄ,u,q,n) = 2ŒΩ_f * ((q*n)‚ãÖ(u-u‚ÇÄ))
  dcomplementary_uv(du,Œµv,n) = 2ŒΩ_f * ((n‚ãÖŒµv)‚ãÖ(du))
  dcomplementary_uq(du,q,n) = 2ŒΩ_f * ((q*n)‚ãÖ(du))
  u0cf(t) = CellField(u0(t),Œì_S)

  # Weak form
  mass(t,(‚àÇ‚Çúu,),(v,)) = ‚à´( ‚àÇ‚Çúu‚ãÖv )dŒ©_f
  res(t,(u,p),(v,q)) =
    ‚à´( (sym_lapl‚àò(Œµ(u),Œµ(v))) +
       (skew_conv‚àò(u,u,v,‚àá(u),‚àá(v))) +
       (div_term‚àò((‚àá‚ãÖu),q)) -
       (div_term‚àò((‚àá‚ãÖv),p)) +
       (œÑ‚Çò‚àò(u‚Çô(u,t),h,h2)) * ((ùí´·µ§‚àò(u‚Çô(u,t),‚àá(u),‚àá(p),Œ∑(u‚Çô(u,t),t)))‚ãÖ((ùíû·µ§‚àò(u‚Çô(u,t),‚àá(v)))+‚àá(q))) +
       (œÑc‚àò(u‚Çô(u,t),h,h2)) * ((‚àá‚ãÖu)*(‚àá‚ãÖv)) )dŒ©_f +
    ‚à´( (skew_conv_Œì‚àò(u,u,v,n_Œìout)) )dŒìout +
    ‚à´( (penalty‚àò(œÑ·µ¶(u‚Çô(u,t),u0cf(t),h,n_ŒìS,t),u0cf(t),u,v)) -
       (complementary_uv‚àò(u0(t),u,Œµ(v),n_ŒìS)) +
       (complementary_uq‚àò(u0(t),u,q,n_ŒìS)) -
       (dcomplementary_uv‚àò(v,Œµ(u),n_ŒìS)) +
       (dcomplementary_uq‚àò(v,p,n_ŒìS)) )dŒì‚Çõ
  jac(t,(u,p),(du,dp),(v,q)) =
    ‚à´( (sym_lapl‚àò(Œµ(du),Œµ(v)))  +
        0.5*((ùíû·µ§‚àò(du,‚àá(u)))‚ãÖv + (ùíû·µ§‚àò(u,‚àá(du)))‚ãÖv - (ùíû·µ§‚àò(du,‚àá(v)))‚ãÖu - (ùíû·µ§‚àò(u,‚àá(v)))‚ãÖdu) +
       (div_term‚àò((‚àá‚ãÖdu),q)) -
       (div_term‚àò((‚àá‚ãÖv),dp)) +
       (œÑ‚Çò‚àò(u‚Çô(u,t),h,h2)) * ((ùíû·µ§‚àò(u‚Çô(u,t),‚àá(du)))+‚àá(dp))‚ãÖ((ùíû·µ§‚àò(u‚Çô(u,t),‚àá(v)))+‚àá(q)) +
       (œÑc‚àò(u‚Çô(u,t),h,h2)) * ((‚àá‚ãÖdu)*(‚àá‚ãÖv)) )dŒ©_f +
    ‚à´( (du‚ãÖv)*(0.5*(u‚ãÖn_Œìout)-neg‚àò(u‚ãÖn_Œìout)) )dŒìout +
    ‚à´( (u‚ãÖv)*(0.5*(du‚ãÖn_Œìout)-neg‚àò(du‚ãÖn_Œìout)) )dŒìout +
    ‚à´( (dpenalty(œÑ·µ¶(u‚Çô(u,t),u0cf(t),h,n_ŒìS,t),du,v)) )dŒì‚Çõ -
    ‚à´( (dcomplementary_uv(du,Œµ(v),n_ŒìS)) )dŒì‚Çõ +
    ‚à´( (dcomplementary_uq(du,q,n_ŒìS)) )dŒì‚Çõ -
    ‚à´( (dcomplementary_uv(v,Œµ(du),n_ŒìS)) )dŒì‚Çõ +
    ‚à´( (dcomplementary_uq(v,dp,n_ŒìS)) )dŒì‚Çõ
  jac_t(t,(u,),(dut,),(v,)) = ‚à´( dut‚ãÖv )dŒ©_f

  # NS operator
  op = TransientSemilinearFEOperator(mass, res, (jac, jac_t), X, Y;constant_mass=true)

  # Nonlinear Solver
  nls = NLSolver(LUSolver(),show_trace=true,method=:newton,iterations=10,ftol=1.0e-6)#, linesearch=BackTracking())
  ls = LUSolver()

  # ########################################
  # # IMEX operators
  # stiffness(t,(u,p),(v,q)) =
  #   ‚à´( (sym_lapl‚àò(Œµ(u),Œµ(v))) +
  #      (div_term‚àò((‚àá‚ãÖu),q)) -
  #      (div_term‚àò((‚àá‚ãÖv),p)) )dŒ©_f
  # im_jac(t,(u,p),(du,dp),(v,q)) = stiffness(t,(du,dp),(v,q))
  # ex_res(t,(u,p),(v,q)) =
  #   ‚à´( (skew_conv‚àò(u,u,v,‚àá(u),‚àá(v))) +
  #       (œÑ‚Çò‚àò(u,h,h2)) * ((ùí´·µ§‚àò(u,‚àá(u),‚àá(p),Œ∑(u,t)))‚ãÖ((ùíû·µ§‚àò(u,‚àá(v)))+‚àá(q))) +
  #       (œÑc‚àò(u,h,h2)) * ((‚àá‚ãÖu)*(‚àá‚ãÖv)) )dŒ©_f +
  #   ‚à´( (skew_conv_Œì‚àò(u,u,v,n_Œìout)) )dŒìout
  # ex_jac(t,(u,p),(du,dp),(v,q)) = ‚à´(0.0*(du‚ãÖv))dŒ©_f
  # im_op = TransientLinearFEOperator((stiffness, mass), (t,y)->0, (im_jac, jac_t), X, Y)#; constant_forms=(true,true))
  # ex_op = TransientFEOperator(ex_res, (ex_jac,), X, Y;assembler=Gridap.ODEs.get_assembler(im_op))
  # println(Gridap.ODEs.get_assembler(im_op))
  # println(Gridap.ODEs.get_assembler(ex_op))
  # imex_op = TransientIMEXFEOperator(im_op, ex_op)
  # ########################################

  # ODE solvers:
  # 1 time step with BE to kill spurious oscillations in force
  ode_solver‚ÇÅ = ThetaMethod(nls,Œît,1.0)
  # ode_solver‚ÇÇ = DIMRungeKutta(nls,ls_mass,Œît,ButcherTableau(SDIRK_Midpoint_1_2()))
  ode_solver‚ÇÇ = GeneralizedAlpha1(nls,Œît,0.5)
  # ode_solver‚ÇÉ = RungeKutta(ls,ls,Œît,:IMEXRK_2_3_2)

  x‚Çú‚ÇÅ = solve(ode_solver‚ÇÅ,op,t‚ÇÄ,t‚ÇÄ+Œît,xh‚ÇÄ)
  function get_step(x‚Çú)
    for (t,x) in x‚Çú
      return x
    end
  end
  xh‚ÇÅ = get_step(x‚Çú‚ÇÅ)
  xh‚ÇÅ‚Çú = (xh‚ÇÅ,interpolate_everywhere([VectorValue(0.0,0.0),0.0],X(t‚ÇÄ+Œît)))
  x‚Çú = solve(ode_solver‚ÇÇ,op,t‚ÇÄ+Œît,tf,xh‚ÇÅ‚Çú)
  # x‚Çú = solve(ode_solver‚ÇÉ,imex_op,t‚ÇÄ+Œît,tf,xh‚ÇÅ)

  # Postprocess
  println("Postprocess")
  global tout = 0
  createpvd("NS_test") do pvd
    for (t,(uh,ph)) in x‚Çú
      to_logfile("Time: $t")
      to_logfile("=======================")
      Fx, Fy = sum(‚à´(2ŒΩ_f*(n_ŒìS ‚ãÖ Œµ(uh)) - ph * n_ŒìS) * dŒì‚Çõ)
      to_forcefile(t,Fx,Fy)
      Œ∑h = buffer[].Œ∑
      if t>=tout
        pvd[t] = createvtk(Œ©,"NS_test_$t",cellfields=["u"=>uh,"p"=>ph,"eta_n"=>Œ∑h,"usgs"=>u‚Çõ(œÑ‚Çò,h,h2,uh,uh,ph,Œ∑h)],order=2)
        tout=t+Œîtout
      end
    end
  end

  close(io)
  close(io_force)

  return nothing
end
